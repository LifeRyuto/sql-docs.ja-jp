---
title: トランザクション分離レベル | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 83197b1b487db6c52a8fe9b7a57dd6af55c33571
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "67985109"
---
# <a name="transaction-isolation-levels"></a>トランザクション分離レベル
*トランザクション分離レベル*分離が成功したトランザクションにエクステントの指標です。 具体的には、トランザクション分離レベルは、次の現象の有無によって定義されます。  
  
-   **ダーティ リード**A*ダーティ リード*トランザクションがまだコミットされていないデータを読み込むときに発生します。 たとえば、トランザクション 1 更新プログラムを行とします。 トランザクション 2 は、トランザクション 1 が、更新をコミットする前に、更新された行を読み取ります。 トランザクション 1 は、変更をロールバック場合、トランザクション 2 は読み取りが存在することはありませんと見なされるデータです。  
  
-   **反復不能読み取り**A*反復不能読み取り*トランザクションは 2 回、同じ行を読み取りますが、毎回異なるデータを取得するときに発生します。 たとえば、1 トランザクション読み取りを行とします。 トランザクション 2 は、更新またはその行を削除し、更新または削除をコミットします。 トランザクション 1 が、行を再読み込みする場合は別の行の値を取得または行が削除されたことを検出します。  
  
-   **ファントム**A*ファントム*は検索条件に一致が最初に認識されない行。 たとえば、トランザクション 1 が一部の検索条件に適合する行セットを読み込むとします。 トランザクション 2 は、トランザクション 1 の検索条件に一致する (更新または挿入) を通じて新しい行を生成します。 トランザクション 1、行を読み取るステートメントを reexecutes、異なる一連の行を取得します。  
  
 4 つのトランザクション分離レベル (、sql-92 で定義) されたが、これらの現象の観点から定義されます。 次の表では、"X"は、各現象が発生することでをマークします。  
  
|トランザクション分離レベル|ダーティ リード|反復不能読み取り|ファントム|  
|---------------------------------|-----------------|-------------------------|--------------|  
|READ UNCOMMITTED|x|X|x|  
|READ COMMITTED|--|x|x|  
|REPEATABLE READ|--|--|x|  
|Serializable|--|--|--|  
  
 次の表では、DBMS が、トランザクション分離レベルを実装が簡単な方法について説明します。  
  
> [!IMPORTANT]  
>  ほとんどの Dbms では、これらよりもさらに複雑なスキームを使用して、同時実行が増加します。 これらの例は、あくまで説明のために提供されます。 ODBC にどのように特定の Dbms が規定されていません具体的には、それぞれ他のトランザクションを分離します。  
  
|トランザクションの分離|考えられる実装|  
|---------------------------|-----------------------------|  
|READ UNCOMMITTED|トランザクションは、互いから分離されていません。 DBMS は、他のトランザクション分離レベルをサポートする場合、これらのレベルを実装するために使用してどのようなメカニズムを無視します。 それらに悪影響を及ぼしません他のトランザクション、Read Uncommitted レベルで実行されているトランザクションになるように、通常は読み取り専用です。|  
|READ COMMITTED|トランザクションは、他のトランザクションで書き込みロックされた行はロックが解除されるまで待機します。「ダーティ」のデータの読み取りができません。<br /><br /> トランザクションは、読み取りロック (行の読み取りしか行わない) 場合や書き込みを他のトランザクションが更新または削除することを防ぐために、現在の行で、(更新または行を削除します) 場合をロックを保持します。 トランザクションは、現在の行外に移動する場合に、読み取りロックを解放します。 コミットまたはロールバックされるまでは、書き込みロックを保持します。|  
|REPEATABLE READ|トランザクションは、他のトランザクションで書き込みロックされた行はロックが解除されるまで待機します。「ダーティ」のデータの読み取りができません。<br /><br /> トランザクションは、すべての行が挿入、更新、または削除でアプリケーションと書き込みのロックを返しますのすべての行の読み取りロックを保持します。 たとえば、トランザクションには、SQL ステートメントが含まれている場合**選択\*から注文**トランザクションの読み取りロックにアプリケーションをフェッチする行。 トランザクションには、SQL ステートメントが含まれている場合**削除からの注文が状態 = 'CLOSED'** トランザクションの書き込みロックは行と、それらを削除します。<br /><br /> 他のトランザクションは、更新または、これらの行を削除できません、ため、現在のトランザクションは、反復不能読み取りを回避します。 トランザクションはコミットまたはロールバック時にロックを解放します。|  
|Serializable|トランザクションは、他のトランザクションで書き込みロックされた行はロックが解除されるまで待機します。「ダーティ」のデータの読み取りができません。<br /><br /> (行の読み取りしか行わない) 場合、トランザクションが読み取りロックを保持または書き込みロック (更新または行を削除する) 場合の範囲の行に影響を与えます。 例では、トランザクションには、SQL ステートメントが含まれている場合、**選択\*から注文**、範囲全体は、Orders テーブルは、トランザクション読み取りロックは、テーブルに挿入する新しい行を許可しません。 トランザクションには、SQL ステートメントが含まれている場合**削除からの注文が状態 = 'CLOSED'** 範囲は、"CLOSED"のステータスを持つすべての行トランザクションの書き込みロックの注文のすべての行テーブルしは、"CLOSED"の状態でない。すべての行を挿入または更新された結果の行がある"CLOSED"の状態を許可します。<br /><br /> 他のトランザクションでは、更新または範囲の行を削除できません、ため、現在のトランザクションは、反復不能読み取りを回避します。 他のトランザクションは、範囲の任意の行を挿入することはできません、ため、現在のトランザクションは、ファントムを回避します。 トランザクションは、コミットまたはロールバック時に、そのロックを解放します。|  
  
 トランザクション分離レベルが、独自の変更を表示するトランザクションの機能に影響しないことに注意してください。トランザクションは、変更することを常に確認できます。 たとえば、トランザクションが 2 つの構成可能性があります**UPDATE**ステートメントのすべての従業員の給与を発生させますが 10% と 2 番目のいくつかその量を最大使用量での任意の従業員の従量課金の設定。 これが成功すると、単一のトランザクションとしてだけであるため、2 つ目**UPDATE**ステートメントは、最初の結果を確認できます。
