---
title: トランザクション分離レベル (ODBC) |マイクロソフトドキュメント
ms.custom: seo-dt-2019
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 622b4cd7f0db259b5ecfd5be63b27df64be965e7
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81298035"
---
# <a name="transaction-isolation-levels-odbc"></a>トランザクション分離レベル (ODBC)
*トランザクション分離レベル*は、トランザクション分離が成功する範囲の基準です。 特に、トランザクション分離レベルは、以下の現象の有無によって定義されます。  
  
-   **汚い読み取り***ダーティ読み取り*は、トランザクションがまだコミットされていないデータを読み取るときに発生します。 たとえば、トランザクション 1 が行を更新するとします。 トランザクション 2 は、トランザクション 1 が更新をコミットする前に更新された行を読み取ります。 トランザクション 1 が変更をロールバックすると、トランザクション 2 は、存在しなかったものと見なされる読み取りデータを持つことになります。  
  
-   **繰り返し不可能な読み取り***繰り返し不可能な読み取り*は、トランザクションが同じ行を 2 回読み取るが、毎回異なるデータを取得する場合に発生します。 たとえば、トランザクション 1 が行を読み取ったとします。 トランザクション 2 は、その行を更新または削除し、更新または削除をコミットします。 トランザクション 1 が行を再読み取りすると、別の行値を取得するか、行が削除されたことが検出されます。  
  
-   **ファントム***ファントム*は、検索条件に一致する行ですが、最初は見られません。 たとえば、トランザクション 1 が、検索条件を満たす一連の行を読み取ったとします。 トランザクション 2 は、トランザクション 1 の検索条件に一致する新しい行 (更新または挿入を介して) を生成します。 トランザクション 1 が、行を読み取るステートメントを再実行すると、異なる行セットを取得します。  
  
 4 つのトランザクション分離レベル (SQL-92 で定義) は、これらの現象の観点から定義されます。 次の表では、"X" は発生する可能性のある各現象を示しています。  
  
|トランザクション分離レベル|汚い読み取り|繰り返し不可能な読み取り|ファントム|  
|---------------------------------|-----------------|-------------------------|--------------|  
|READ UNCOMMITTED|X|X|X|  
|READ COMMITTED|--|X|X|  
|REPEATABLE READ|--|--|X|  
|シリアル化可能|--|--|--|  
  
 次の表では、DBMS がトランザクション分離レベルを実装する簡単な方法について説明します。  
  
> [!IMPORTANT]  
>  ほとんどの DBMS では、同時実行性を高めるために、これらよりも複雑なスキームを使用します。 これらの例は、説明の目的でのみ提供されています。 特に、ODBC では、特定の Dbms がトランザクションを互いに分離する方法は規定されていません。  
  
|トランザクションの分離|可能な実装|  
|---------------------------|-----------------------------|  
|READ UNCOMMITTED|トランザクションは互いに分離されません。 DBMS が他のトランザクション分離レベルをサポートしている場合、DBMS は、そのレベルを実装するために使用するメカニズムを無視します。 他のトランザクションに悪影響を及ぼさないため、Read Uncommitted レベルで実行されているトランザクションは、通常は読み取り専用です。|  
|READ COMMITTED|トランザクションは、他のトランザクションによって書き込みロックされた行がロック解除されるまで待機します。これにより、"ダーティ" データが読み取れなくなります。<br /><br /> トランザクションは、他のトランザクションが更新または削除できないように、現在の行に対して読み取りロック (行を読み取る場合のみ) または書き込みロック (行を更新または削除する場合) を保持します。 トランザクションは、現在の行から移動すると読み取りロックを解放します。 コミットまたはロールバックされるまで、書き込みロックを保持します。|  
|REPEATABLE READ|トランザクションは、他のトランザクションによって書き込みロックされた行がロック解除されるまで待機します。これにより、"ダーティ" データが読み取れなくなります。<br /><br /> トランザクションは、アプリケーションに返されるすべての行に対する読み取りロックを保持し、挿入、更新、または削除するすべての行に対して書き込みロックを保持します。 たとえば、トランザクションに SQL ステートメント**SELECT \* FROM Orders**が含まれている場合、アプリケーションが行をフェッチすると、トランザクションはローを読み取りロックします。 トランザクションに SQL ステートメント**DELETE FROM ORDERS WHERE Where Status = 'CLOSED'** が含まれている場合、トランザクションは行を削除する時に行を書き込みロックします。<br /><br /> 他のトランザクションはこれらの行を更新または削除できないため、現在のトランザクションは繰り返し不可能な読み取りを回避します。 トランザクションは、コミットまたはロールバックされたときにロックを解放します。|  
|シリアル化可能|トランザクションは、他のトランザクションによって書き込みロックされた行がロック解除されるまで待機します。これにより、"ダーティ" データが読み取れなくなります。<br /><br /> トランザクションは、そのトランザクションが影響を受ける行の範囲に対して読み取りロック (行のみを読み取る場合) または書き込みロック (更新または削除が可能な場合) を保持します。 たとえば、トランザクションに SQL ステートメント**SELECT \* FROM Orders**が含まれている場合、範囲は Orders テーブル全体になります。トランザクションはテーブルを読み取りロックし、新しい行を挿入することはできません。 トランザクションに、SQL ステートメント**DELETE FROM 注文 WHERE ステータス = 'CLOSED'** が含まれている場合、範囲はステータスが "CLOSED" のすべての行になります。トランザクションは、ステータスが "CLOSED" の Orders テーブルのすべての行を書き込みロックし、結果の行のステータスが "CLOSED" になるように行を挿入または更新することはできません。<br /><br /> 他のトランザクションは範囲内の行を更新または削除できないため、現在のトランザクションは繰り返し不可能な読み取りを回避します。 他のトランザクションは範囲内の行を挿入できないため、現在のトランザクションはファントムを回避します。 トランザクションは、コミットまたはロールバックされたときにロックを解放します。|  
  
 トランザクション分離レベルは、トランザクションが自身の変更を確認する能力に影響を与えないことに注意してください。トランザクションは、変更を常に確認できます。 たとえば、トランザクションは 2 つの**UPDATE**ステートメントで構成され、最初の明細書では全従業員の賃金が 10% 上がり、2 つ目の明細書では従業員の給与が上限金額を 10% 引き上げることができます。 2 番目の**UPDATE**ステートメントが最初の UPDATE ステートメントの結果を見ることができるため、これは単一のトランザクションとして成功します。
