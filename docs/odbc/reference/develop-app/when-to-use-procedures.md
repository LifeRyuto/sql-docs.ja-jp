---
title: 手続きを使用する場合 |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 31aeea226bc8c8aa41f748d1d9a97d55147c4d67
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81289099"
---
# <a name="when-to-use-procedures"></a>プロシージャを使用する場合
プロシージャを使用すると、SQL ステートメントがアプリケーションからデータ ソースに移動するという事実に基づいて、プロシージャを使用する利点が数多くあります。 アプリケーションに残っているのは、相互運用可能なプロシージャ呼び出しです。 これらの利点は次のとおりです。  
  
-   **パフォーマンス**通常、プロシージャは SQL ステートメントを実行する最も高速な方法です。 準備された実行と同様に、ステートメントはコンパイルされ、2 つの別々のステップで実行されます。 準備された実行とは異なり、プロシージャは実行時にのみ実行されます。 これらは別の時刻にコンパイルされます。  
  
-   **ビジネスルール***ビジネス ルール*は、企業がビジネスを行う方法に関するルールです。 たとえば、"営業担当者" というタイトルの人だけが、新しい販売注文を追加できます。 これらの規則を手順に入れることで、個々の企業は、アプリケーション コードを変更することなく、アプリケーションによって呼び出されるプロシージャを書き換えることによって、垂直アプリケーションをカスタマイズできます。 たとえば、注文入力アプリケーションは、一定の数のパラメータを指定して**InsertOrder**プロシージャを呼び出します。**InsertOrder**の実装方法は、会社によって異なります。  
  
-   **交換可能性**ビジネス ルールをプロシージャに配置することに密接に関連しているのは、アプリケーションを再コンパイルしなくてもプロシージャを置き換えることができるということです。 企業がアプリケーションを購入してインストールした後でビジネス ルールが変更された場合、会社はそのルールを含む手順を変更できます。 アプリケーションの観点からは、何も変わっていません。特定のタスクを実行するために、特定のプロシージャを呼び出します。  
  
-   **DBMS 固有の SQL**プロシージャは、アプリケーションが DBMS 固有の SQL を利用し、引き続き相互運用可能な状態を維持する方法を提供します。 たとえば、SQL でフロー制御ステートメントをサポートする DBMS 上のプロシージャは、エラーをトラップして回復し、フロー制御ステートメントをサポートしない DBMS 上のプロシージャは単にエラーを返す場合があります。  
  
-   **手続きは取引を生き残る**一部のデータ・ソースでは、トランザクションがコミットまたはロールバックされると、接続上のすべての準備済みステートメントのアクセス・プランが削除されます。 SQL ステートメントをプロシージャに配置し、データ ソースに永続的に格納すると、ステートメントはトランザクションを存続します。 プロシージャが準備済み、部分的に準備された状態、または準備されていない状態で残っているかどうかは、DBMS に固有です。  
  
-   **個別の開発**手順は、アプリケーションの残りの部分とは別に開発することができます。 大企業では、高度に専門性の高いプログラマのスキルをさらに活用する方法を提供する可能性があります。 つまり、アプリケーション プログラマはユーザー インターフェイス コードを記述でき、データベース プログラマはプロシージャを記述できます。  
  
 プロシージャは通常、垂直アプリケーションやカスタム アプリケーションで使用されます。 これらのアプリケーションは固定タスクを実行する傾向があり、プロシージャ呼び出しをハードコーディングすることができます。 たとえば、注文入力アプリケーションは、プロシージャを呼び出す可能性があります、**挿入順序**、**削除順序**、**更新順序**、および**GetOrder**。  
  
 汎用アプリケーションからプロシージャを呼び出す理由はほとんどありません。 プロシージャは通常、特定のアプリケーションのコンテキストでタスクを実行するために作成されるため、汎用アプリケーションには使用できません。 たとえば、スプレッドシートには、前述の**InsertOrder**プロシージャを呼び出す理由がありません。 さらに、汎用アプリケーションは、ステートメントの実行を高速化するために、実行時にプロシージャを構築すべきではありません。これは準備または直接実行よりも遅くなる可能性があるだけでなく、DBMS 固有の SQL ステートメントも必要です。  
  
 例外はアプリケーション開発環境で、多くの場合、プログラマがプロシージャを実行する SQL ステートメントを作成する方法を提供し、プログラマがプロシージャをテストする方法を提供します。 このような環境では **、SQLProcedure を**呼び出して、使用可能なプロシージャと**SQLProcedureColumns を**リストして、入力パラメーター、入出力パラメーター、プロシージャの戻り値、およびプロシージャによって作成された結果セットの列を一覧表示します。 ただし、このようなプロシージャは、事前に各データ ソースで開発する必要があります。これを行うには、DBMS 固有の SQL ステートメントが必要です。  
  
 プロシージャを使用する場合、3 つの大きな欠点があります。 1 つ目は、アプリケーションを実行する DBMS ごとにプロシージャを作成してコンパイルする必要があるということです。 これはカスタム アプリケーションでは問題ありませんが、多くの Dbms で実行するように設計された垂直アプリケーションの開発と保守にかかる時間が大幅に増加する可能性があります。  
  
 2 つ目の欠点は、多くの DBMS がプロシージャをサポートしていないということです。 ここでも、これは多くの Dbms で動作するように設計された垂直アプリケーションの場合に問題になる可能性があります。 プロシージャがサポートされているかどうかを確認するために、アプリケーションは SQL_PROCEDURES オプションを指定して**SQLGetInfo**を呼び出します。  
  
 アプリケーション開発環境に特に当てはまる 3 番目の欠点は、ODBC がプロシージャを作成するための標準文法を定義しないことです。 つまり、アプリケーションは、相互運用可能な方法でプロシージャを呼び出すことができますが、相互運用可能に作成することはできません。
