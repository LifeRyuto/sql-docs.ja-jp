---
title: アライメント |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 205cc3ff95dd60db215150f46ae894fbb99bd9ff
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81288607"
---
# <a name="alignment"></a>Alignment
ODBC アプリケーションの配置の問題は、通常、他のアプリケーションと同じです。 つまり、ほとんどの ODBC アプリケーションでは、配置に関する問題がほとんどまたはまったくありません。 アドレスを整列しない場合のペナルティは、ハードウェアとオペレーティング システムによって異なり、パフォーマンスの低下や致命的な実行時エラーと同じくらい軽微な場合があります。 したがって、ODBC アプリケーション、特に移植可能な ODBC アプリケーションは、データを適切に配置するように注意する必要があります。  
  
 ODBC アプリケーションで整列の問題が発生する例の 1 つとして、大量のメモリ ブロックを割り当て、結果セット内の列にそのメモリの異なる部分をバインドする場合があります。 これは、汎用アプリケーションが実行時に結果セットの形状を決定し、それに応じてメモリを割り当ててバインドする必要がある場合に発生する可能性が最も高いです。  
  
 たとえば、アプリケーションがユーザーが入力した**SELECT**ステートメントを実行し、このステートメントから結果をフェッチするとします。 プログラムの作成時にこの結果セットの形状が不明なため、アプリケーションは結果セットの作成後に各列の型を決定し、それに応じてメモリをバインドする必要があります。 これを行う最も簡単な方法は、メモリの大きなブロックを割り当て、そのブロック内の異なるアドレスを各列にバインドすることです。 列のデータにアクセスするために、アプリケーションはその列にバインドされたメモリをキャストします。  
  
 次の図は、結果セットのサンプルと、各 SQL データ型の既定の C データ型を使用してメモリ ブロックをバインドする方法を示しています。 各 "X" は、メモリの 1 バイトを表します。 (この例では、列にバインドされているデータ バッファーのみを示します。 これは、わかりやすくするために行われます。 実際のコードでは、長さ/インジケーター バッファーも揃える必要があります。  
  
 ![既定の C データ型から SQL データ型へのバインド](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 バインドされたアドレスが*Address*配列に格納されていると仮定すると、アプリケーションは次の式を使用して、各列にバインドされたメモリにアクセスします。  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 2 番目と 3 番目の列にバインドされたアドレスは奇数バイトから始まり、3 番目の列にバインドされたアドレスは 4 (SDWORD のサイズ) で割り切れないことを確認します。 一部のマシンでは、これは問題ではありません。他の人には、それはわずかなパフォーマンスのペナルティを引き起こすでしょう。それ以外の場合、致命的な実行時エラーが発生します。 適切な解決策は、各バインドされたアドレスを自然な位置合わせ境界に揃える方法です。 UCHAR の場合は 1、SWORD の場合は 2、SDWORD の場合は 4 であると仮定すると、次の図に示す結果が示されます。  
  
 ![自然な配置境界によるバインド](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 このソリューションでは、アプリケーションのメモリがすべて使用されるわけではありませんが、アライメントの問題は発生しません。 残念ながら、各列は型に応じて個別に配置する必要がありますので、このソリューションを実装するには、かなりの量のコードが必要です。 より簡単な解決策は、すべての列を最大の位置合わせ境界のサイズに合わせて配置することです。  
  
 ![最大の配置境界によるバインド](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 このソリューションは大きな穴を残しますが、実装するコードは比較的シンプルで高速です。 ほとんどの場合、未使用メモリで支払われるペナルティを相殺します。 このメソッドを使用する例については、「 [SQLBindCol の使用](../../../odbc/reference/develop-app/using-sqlbindcol.md)」を参照してください。
