---
title: データ長、バッファ長、切り捨て |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- data buffers [ODBC], length
- data length [ODBC]
- truncating data [ODBC]
- length of data buffers [ODBC]
- buffers [ODBC], length
ms.assetid: 2825c6e7-b9ff-42fe-84fc-7fb39728ac5d
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: b2e7b8d1e60cd83594509c2ab5cbc24e04546eca
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81305233"
---
# <a name="data-length-buffer-length-and-truncation"></a>データの長さ、バッファー長、および切り捨て
*データ長*は、データ・ソースに保管されるデータではなく、アプリケーションのデータ・バッファーに保管されるデータのバイト長です。 データはデータ ソースとは異なるデータ バッファーに格納されることが多いため、この区別は重要です。 したがって、データ ソースに送信されるデータの場合、これはデータ ソースの型に変換する前のデータのバイト長です。 データ ソースから取得されるデータの場合、これはデータ バッファーの型に変換した後、および切り捨てが行われる前のデータのバイト長です。  
  
 整数や日付構造体などの固定長データの場合、データのバイト長は常にデータ型のサイズになります。 一般に、アプリケーションはデータ型のサイズであるデータ バッファーを割り当てます。 アプリケーションが小さいバッファーを割り当てる場合、ドライバーはデータ バッファーがデータ型のサイズであると想定し、より小さいバッファーに収まるようにデータを切り捨てないので、結果は未定義になります。 アプリケーションが大きなバッファーを割り当てる場合、余分なスペースは使用されません。  
  
 文字データやバイナリ データなどの可変長データの場合、データのバイト長はバッファーのバイト長とは別であり、多くの場合は異なることを認識することが重要です。 これら 2 つの長さの関係については、「[バッファー」](../../../odbc/reference/develop-app/buffers.md)セクションで説明します。 データのバイト長がバッファーのバイト長より大きい場合、ドライバーはフェッチされたデータをバッファーのバイト長まで切り捨て、SQLSTATE 01004 (データ切り捨て) でSQL_SUCCESS_WITH_INFOを戻します。 ただし、返されるバイト長は、切り捨てられていないデータの長さです。  
  
 たとえば、アプリケーションがバイナリ データ バッファーに 50 バイトを割り当てるとします。 ドライバーが返すバイナリ データの 10 バイトを持っている場合、バッファー内のそれらの 10 バイトを返します。 データのバイト長は 10 で、バッファーのバイト長は 50 です。 返す 60 バイトのバイナリ データがドライバーにある場合、データを 50 バイトに切り捨て、バッファー内のそれらのバイトを返し、SQL_SUCCESS_WITH_INFO返します。 データのバイト長は 60 (切り捨て前の長さ) であり、バッファーのバイト長は依然として 50 です。  
  
 切り捨てられた各列に対して診断レコードが作成されます。 ドライバーがこれらのレコードを作成し、アプリケーションでレコードを処理するには時間がかかるため、切り捨てによってパフォーマンスが低下する可能性があります。 通常、アプリケーションは、十分な大きさのバッファーを割り当てることによってこの問題を回避できますが、長いデータを扱う場合には、この問題は不可能です。 データの切り捨てが発生すると、アプリケーションは大きなバッファを割り当ててデータを再フェッチすることがあります。これはすべての場合に当てはまるわけではありません。 **SQLGetData**の呼び出しを使用してデータを取得しているときに切り捨てが発生した場合、アプリケーションは既に返されたデータに対して**SQLGetData**を呼び出す必要はありません。詳細については、「[長いデータの取得](../../../odbc/reference/develop-app/getting-long-data.md)」を参照してください。
