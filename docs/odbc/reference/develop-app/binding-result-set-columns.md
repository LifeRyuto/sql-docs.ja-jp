---
title: 結果セット列のバインド |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- result sets [ODBC], binding columns
- binding columns [ODBC]
ms.assetid: 4bc9c30f-83ae-4766-a746-032953c187ad
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 558ceb79d42d82477b70a028395de82cc023c170
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81306363"
---
# <a name="binding-result-set-columns"></a>結果セットの列のバインド
アプリケーションは、列をまったくバインドしないなど、結果セットの列を選択した数だけ、または少ない数だけバインドできます。 データ行がフェッチされると、ドライバーはバインドされた列のデータをアプリケーションに返します。 アプリケーションが結果セット内のすべての列をバインドするかどうかは、アプリケーションによって異なります。 たとえば、レポートを生成するアプリケーションは、通常、固定形式です。このようなアプリケーションは、レポートで使用されるすべての列を含む結果セットを作成し、これらの列のデータをバインドして取得します。 データが満杯の画面を表示するアプリケーションでは、ユーザーが表示する列を決定できる場合があります。このようなアプリケーションは、ユーザーが必要とするすべての列を含む結果セットを作成しますが、バインドして、ユーザーが選択した列のデータのみを取得します。  
  
 **SQLGetData**を呼び出すことによって、バインドされていない列からデータを取得できます。 これは、長いデータを取得するために一般的に呼び出されます。  
  
 行がフェッチされた後でも、列はいつでもバインドできます。 ただし、新しいバインディングは、次に行がフェッチされるまで有効になりません。既にフェッチされている行のデータには適用されません。  
  
 変数は、別の変数が列にバインドされるまで、SQL_UNBINDオプションを指定して**SQLFreeStmt**を呼び出してすべての列がバインド解除されるまで、またはステートメントが解放されるまで、列が NULL ポインターを持つ**SQLBindCol**を呼び出してバインドされないまで、列にバインドされたままになります。 このため、アプリケーションは、バインドされているすべての変数がバインドされている限り有効な状態を維持する必要があります。 詳細については、「[バッファの割り当てと解放](../../../odbc/reference/develop-app/allocating-and-freeing-buffers.md)」を参照してください。  
  
 列バインディングはステートメント構造に関連付けられた情報にすぎないため、任意の順序で設定できます。 また、結果セットから独立しています。 たとえば、アプリケーションが次の SQL ステートメントによって生成された結果セットの列をバインドするとします。  
  
```  
SELECT * FROM Orders  
```  
  
 アプリケーションが SQL ステートメントを実行する場合  
  
```  
SELECT * FROM Lines  
```  
  
 同じステートメント ハンドルでは、最初の結果セットの列のバインディングは、ステートメント構造に格納されているバインディングであるため、有効です。 ほとんどの場合、これはプログラミングの習慣が悪いため、避けるべきです。 代わりに、アプリケーションは、すべての古い列をバインド解除し、新しい列をバインドするSQL_UNBINDオプションを使用して**SQLFreeStmt**を呼び出す必要があります。
