---
title: データ行のフェッチ |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetch function [ODBC], fetching a row of data
- cursors [ODBC], fetching rows
- result sets [ODBC], fetching
- fetches [ODBC], row of data
ms.assetid: 16d4a380-0d83-456b-aeee-f10738944e86
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a702f561b756d5305020df9f015d3ea4b444caa6
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81305673"
---
# <a name="fetching-a-row-of-data"></a>データの行のフェッチ
データの行をフェッチするには、アプリケーションは**SQLFetch**を呼び出します。 **SQLFetch**は、任意の種類のカーソルを使用して呼び出すことができますが、行セット カーソルは前方のみの方向に移動するだけです。 **SQLFetch**は、カーソルを次の行に進め **、SQLBindCol**の呼び出しでバインドされた列のデータを返します。 カーソルが結果セットの末尾に達すると **、SQLFetch は**SQL_NO_DATAを返します。 **SQLFetch**の呼び出しの例については、「 [SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)の使用 」を参照してください。  
  
 **SQLFetch**の実装方法はドライバーに固有ですが、一般的なパターンは、ドライバーがデータ ソースからバインドされた列のデータを取得し、バインドされた変数の型に従って変換し、変換されたデータをそれらの変数に配置することです。 ドライバーは、任意のデータを変換できない場合は、**エラー**を返します。 アプリケーションは行のフェッチを続行できますが、現在の行のデータは失われます。 非バインド列のデータに何が起こるかは、ドライバーによって異なりますが、ほとんどのドライバーは、ドライバーを取得して破棄するか、まったく取得しません。  
  
 ドライバーはまた、バインドされている任意の長さ/インジケーター バッファーの値を設定します。 列のデータ値が NULL の場合、ドライバーは、対応する長さ/インジケーター バッファーをSQL_NULL_DATAに設定します。 データ値が NULL でない場合、ドライバーは、変換後のデータのバイト長に長さ/インジケーター バッファーを設定します。 この長さを決定できない場合は、複数の関数呼び出しによって取得される長いデータの場合と同様に、ドライバーは長さ/インジケーター バッファーをSQL_NO_TOTALに設定します。 整数や日付構造体などの固定長データ型の場合、バイト長はデータ型のサイズになります。  
  
 文字データやバイナリ データなどの可変長データの場合、ドライバーは、変換されたデータのバイト長を、列にバインドされたバッファーのバイト長と照合します。バッファーの長さは、 **SQLBindCol**の*引数 BufferLength*で指定します。 変換されたデータのバイト長がバッファーのバイト長より大きい場合、ドライバーはバッファーに収まるようにデータを切り捨て、長さ/インジケーター バッファーの切り捨てられていない長さを返し、SQL_SUCCESS_WITH_INFOを返し、SQLSTATE 01004 (データ切り捨て) を診断に配置します。 唯一の例外は **、SQLFetch**によって返されたときに可変長ブックマークが切り捨てられる場合です。  
  
 固定長データは、バインドされたバッファーのサイズがデータ型のサイズであると想定しているため、切り捨てられないことはありません。 通常、アプリケーションはデータ値全体を保持するのに十分な大きさのバッファーをバインドするため、データの切り捨てはまれです。メタデータから必要なサイズを決定します。 ただし、アプリケーションは、小さすぎると認識しているバッファーを明示的にバインドする可能性があります。 たとえば、部品記述の最初の 20 文字、または長いテキスト列の最初の 100 文字を取得して表示できます。  
  
 文字データは、切り捨てられた場合でも、アプリケーションに返される前に、ドライバーによって null 終了する必要があります。 戻されたバイト長には NULL 終了文字は含まれませんが、バインドされたバッファーにスペースが必要です。 たとえば、アプリケーションが ASCII 文字セットの文字データで構成される文字列を使用し、ドライバーが返すデータの 50 文字を持ち、アプリケーションのバッファーの長さは 25 バイトであるとします。 アプリケーションのバッファーでは、ドライバーは、最初の 24 文字の後に null 終了文字を返します。 長さ/インジケーターバッファーでは、バイト長 50 を戻します。  
  
 アプリケーションは、結果セットを作成するステートメントを実行する前に SQL_ATTR_MAX_ROWS ステートメント属性を設定することにより、結果セット内の行数を制限できます。 たとえば、レポートの書式設定に使用するアプリケーションのプレビュー モードでは、レポートの最初のページを表示するのに十分なデータしか必要としません。 結果セットのサイズを制限することで、このような機能の実行速度が速くなります。 このステートメント属性は、ネットワーク トラフィックを削減することを目的としており、すべてのドライバーでサポートされているわけではありません。
