---
title: SQL フェッチスクロール (カーソル ライブラリ) |マイクロソフトドキュメント
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetchScroll function [ODBC], Cursor Library
ms.assetid: 4417e57c-31dd-475e-8fe9-eab00a459c80
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: e5573b8afc49afec8b7afa4fc52590e7a6a9e2fb
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/14/2020
ms.locfileid: "81302053"
---
# <a name="sqlfetchscroll-cursor-library"></a>SQLFetchScroll (カーソル ライブラリ)
> [!IMPORTANT]  
>  この機能は、今後のバージョンの Windows で削除される予定です。 新しい開発作業でこの機能を使用することは避け、現在この機能を使用しているアプリケーションを変更する予定です。 マイクロソフトでは、ドライバーのカーソル機能を使用することをお勧めします。  
  
 このトピックでは、カーソル ライブラリでの**SQLFetchScroll**関数の使用について説明します。 **SQL フェッチスクロール**の一般的な情報については[、「SQL フェッチスクロール関数](../../../odbc/reference/syntax/sqlfetchscroll-function.md)」を参照してください。  
  
 カーソル ライブラリは、ドライバーで**SQLFetch**を繰り返し呼び出すことによって**SQLFetchScroll**を実装します。 ドライバーから取得したデータを、アプリケーションによって提供される行セット バッファーに転送します。 また、メモリファイルとディスクファイルにデータをキャッシュします。 アプリケーションが新しい行セットを要求すると、カーソル ライブラリは、必要に応じて、ドライバー (以前にフェッチされていない場合) またはキャッシュ (以前にフェッチされている場合) から取得します。 最後に、カーソル ライブラリはキャッシュされたデータの状態を保持し、この情報を行の状態配列内のアプリケーションに返します。  
  
 カーソル ライブラリを使用する場合 **、SQLFetchScroll**の呼び出しを **、SQLFetch**または**SQLExtendedFetch**の呼び出しと混在することはできません。  
  
 カーソル ライブラリを使用する場合 **、SQLFetchScroll**への呼び出しは、ODBC 2 の両方でサポートされます。*x*と ODBC 3 の場合。*x*ドライバ。  
  
## <a name="rowset-buffers"></a>行セット バッファー  
 カーソル ライブラリは、次の場合に、ドライバーからアプリケーションによって提供される行セット バッファーへのデータ転送を最適化します。  
  
-   アプリケーションは、行方向のバインドを使用します。  
  
-   アプリケーションがデータ行を保持すると宣言する構造体のフィールド間に未使用のバイトはありません。  
  
-   SQLFetch または**SQLFetchScroll**が列の長さ/インジケーターを返すフィールドは、その列のバッファーの後に続き、次の列のバッファーの前に置かれます。 **SQLFetchScroll** これらのフィールドは省略可能です。  
  
 アプリケーションが新しい行セットを要求すると、必要に応じて、カーソル ライブラリはキャッシュとドライバーからデータを取得します。 新しい行セットと古い行セットが重なっている場合、カーソル ライブラリは行セット バッファーの重複するセクションのデータを再利用することで、そのパフォーマンスを最適化できます。 したがって、行セット バッファーに対する保存されていない変更は、新しい行セットと古い行セットが重なり合って行セット バッファーの重複するセクションに含まれている場合を除き、失われます。 変更を保存するために、アプリケーションは位置指定更新ステートメントを送信します。  
  
 カーソル ライブラリは、アプリケーションが*fetchOrientation*引数を SQL_FETCH_RELATIVE に設定し *、FetchOffset*引数を 0 に設定して**SQLFetchScroll**を呼び出すと、常に行セット バッファーをキャッシュからのデータで更新することに注意してください。  
  
 カーソル ライブラリは、カーソルがオープンされている間に行セットのサイズを変更する*SQL_ATTR_ROW_ARRAY_SIZEの属性*を指定して**SQLSetStmtAttr**を呼び出すことをサポートしています。 新しい行セットのサイズは、次に**SQLFetchScroll**が呼び出されると有効になります。  
  
## <a name="result-set-membership"></a>結果セットのメンバーシップ  
 カーソル ライブラリは、アプリケーションが要求した場合にのみ、ドライバーからデータを取得します。 データ ソースと SQL_CONCURRENCY ステートメント属性の設定に応じて、次の結果が発生します。  
  
-   カーソル ライブラリによって取得されたデータは、ステートメントの実行時に使用可能だったデータと異なる場合があります。 たとえば、カーソルが開かれた後、現在のカーソル位置を超える位置に挿入された行は、一部のドライバで取得できます。  
  
-   結果セット内のデータは、カーソル ライブラリのデータ ソースによってロックされている可能性があるため、他のユーザーは使用できません。  
  
 カーソル ライブラリがデータの行をキャッシュした後、基になるデータ ソースのその行に対する変更を検出できません (位置指定更新と同じカーソルのキャッシュで動作している削除を除く)。 これは **、SQLFetchScroll**を呼び出す場合、カーソル ライブラリがデータ ソースからデータを再フェッチしないために発生します。 代わりに、キャッシュからデータを再フェッチします。  
  
## <a name="scrolling"></a>スクロール  
 カーソル ライブラリは **、SQLFetchScroll**で次のフェッチの種類をサポートしています。  
  
|カーソルの種類|フェッチタイプ|  
|-----------------|-----------------|  
|順方向専用|SQL_FETCH_NEXT|  
|静的|SQL_FETCH_NEXT<br /><br /> SQL_FETCH_PRIOR<br /><br /> SQL_FETCH_FIRST<br /><br /> SQL_FETCH_LAST<br /><br /> SQL_FETCH_RELATIVE<br /><br /> SQL_FETCH_ABSOLUTE<br /><br /> SQL_FETCH_BOOKMARK|  
  
## <a name="errors"></a>エラー  
 **SQLFetchScroll**が呼び出され **、SQLFetch**の呼び出しの 1 つがSQL_ERRORを返すと、カーソル ライブラリは次のように処理されます。 これらのステップが完了すると、カーソル・ライブラリーは処理を継続します。  
  
1.  ドライバーからエラー情報を取得する**SQLGetDiagRec**を呼び出し、ドライバー マネージャーで診断レコードとしてこれを投稿します。  
  
2.  診断レコードのSQL_DIAG_ROW_NUMBERフィールドを適切な値に設定します。  
  
3.  診断レコードのSQL_DIAG_COLUMN_NUMBERフィールドに適切な値を設定します (該当する場合)。それ以外の場合は、0 に設定されます。  
  
4.  行の状態配列のエラーの行の値をSQL_ROW_ERRORに設定します。  
  
 カーソル ライブラリが**SQLFetchScroll**の実装で**SQLFetch**を複数回呼び出した後 **、SQLFetch**の呼び出しの 1 つによって返されるエラーまたは警告は診断レコードに入れ **、SQLGetDiagRec**の呼び出しによって取得できます。 フェッチ時にデータが切り捨てられた場合、切り捨てられたデータはカーソル ライブラリのキャッシュに格納されます。 後続の**SQLFetchScroll**を呼び出して、切り捨てられたデータのある行にスクロールすると、切り捨てられたデータが返され、カーソル ライブラリのキャッシュからデータがフェッチされるため、警告は発生しません。 バッファーに戻されたデータが切り捨てられたかどうかを判断できるように、戻されるデータの長さを追跡するために、アプリケーションは長さ/インジケーター バッファーをバインドする必要があります。  
  
## <a name="bookmark-operations"></a>ブックマーク操作  
 カーソル ライブラリでは、SQL_FETCH_BOOKMARKの*フェッチオリエンテーション*を使用して**SQLFetchScroll**を呼び出すがサポートされています。 また、ブックマーク操作で使用できる*FetchOffset*引数のオフセットの指定もサポートしています。 これは、カーソル ライブラリがサポートする唯一のブックマーク操作です。 カーソル ライブラリは**SQLBulkOperations**の呼び出しをサポートしていません。  
  
 アプリケーションが SQL_ATTR_USE_BOOKMARKS ステートメント属性を設定し、ブックマーク列にバインドされている場合、カーソル ライブラリは固定長のブックマークを生成し、アプリケーションに返します。 カーソル ライブラリは、使用するブックマークを作成して維持します。データ ソースで保持されているブックマークは使用しません。 **SQLFetchScroll**が呼び出されて、データ ソースから既にフェッチされているデータのブロックを取得すると、カーソル ライブラリ キャッシュからデータが取得されます。 その結果、SQL_FETCH_BOOKMARKの*フェッチオリエンテーション*を使用して**SQLFetchScroll**の呼び出しで使用されるブックマークは、カーソル ライブラリによって作成および維持する必要があります。  
  
## <a name="interaction-with-other-functions"></a>他の関数との相互作用  
 アプリケーションは、位置指定更新または削除ステートメントを準備または実行する前に **、SQLFetch**または**SQLFetchScroll**を呼び出す必要があります。
